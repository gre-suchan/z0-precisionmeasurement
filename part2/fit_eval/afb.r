library(dplyr)
library(magrittr)
library(deming)

# Read in the data generated by the A_FB evaluation
df <- read.csv("../../plot_data/part2/forward_backward/A_FB.csv",
               col.names=c("sqrt.s", "N.f","N.b","N.f.err","N.b.err", "A.FB",
                           "A.FB.err","sin.W","sin.W_err", "sqrt.s.err"), 
               skip=2)
df$A.FB.err %<>% abs
# Plot the forward-backward asymmetry against sqrt(s)
df %$%
    plot(sqrt.s, A.FB)
df %$%
    arrows(sqrt.s, A.FB-A.FB.err,
           sqrt.s, A.FB+A.FB.err,
           length=.05, angle=90, code=3)
df %$%
    arrows(sqrt.s-sqrt.s.err, A.FB,
           sqrt.s+sqrt.s.err, A.FB,
           length=.05, angle=90, code=3)

# Now, do a linear fit on
fit <- lm(A.FB ~ sqrt.s, data=df, weights=1/A.FB.err^2)
abline(fit, col='red')

deming.fit <- deming(A.FB ~ sqrt.s, data=df, xstd=sqrt.s.err, ystd=A.FB.err)
abline(deming.fit, col='blue')

# Our measured Z mass
M.Z <- 91.19046
M.Z.err <- 0.05137956


########################
#  Regular regression  #
########################

# Forward backward asymmetry at resonance by linear model prediction
A.FB.res <- as.numeric(predict(fit, newdata=data.frame(sqrt.s=c(M.Z))))
# Propagate error
grad <- c(1, M.Z, coef(fit)[2])
# Construct a covariance matrix out of the fit covariance matrix and the error
# on M.Z
v <- vcov(fit) %>%
    rbind(0) %>%
    cbind(c(0, 0, M.Z.err^2))
A.FB.res.err <- as.numeric(sqrt(grad %*% v %*% grad))

points(M.Z, A.FB.res, col='blue')
arrows(M.Z, A.FB.res-A.FB.res.err,
       M.Z, A.FB.res+A.FB.res.err,
       length=.05, angle=90, code=3)

# From A.Fb.res calculate the sin^2 of the Weinberg angle
sin2.W <- 1/4 * (1 - sqrt(abs(A.FB.res/3)))
sin2.W.err <- 1/24 * A.FB.res.err / sqrt(abs(A.FB.res) / 3)
sprintf("Estimate for sin^2(Theta_W): %g +- %g", sin2.W, sin2.W.err)


#######################
#  Deming regression  #
#######################

# The regular linear model doesn't take errors in the predictor variable into
# account as it is a standard regression.
# With R's deming package we attempt a deming regression and try to calculate
# the squared sine of the weinberg angle

A.FB.res.alt <- deming.fit$coefficients %>% 
    {.[1] + .[2]*M.Z} %>% 
    as.numeric
grad.alt <- as.numeric(c(1, M.Z, deming.fit$coefficients[2]))
v.alt <- deming.fit$variance %>%
    rbind(0) %>%
    cbind(c(0, 0, M.Z.err^2))
A.FB.res.alt.err <- as.numeric(sqrt(grad.alt %*% v.alt %*% grad.alt))
points(M.Z, A.FB.res.alt, col='green')
arrows(M.Z, A.FB.res.alt-A.FB.res.alt.err,
       M.Z, A.FB.res.alt+A.FB.res.alt.err,
       length=.05, angle=90, code=3)

# From A.Fb.res.alt calculate the sin^2 of the Weinberg angle
sin2.W.alt <- 1/4 * (1 - sqrt(abs(A.FB.res.alt/3)))
sin2.W.alt.err <- 1/24 * A.FB.res.alt.err / sqrt(abs(A.FB.res.alt) / 3)
sprintf("Alternative estimate for sin^2(Theta_W): %g +- %g", sin2.W.alt, sin2.W.alt.err)

legend(x="topleft", 
       legend=c("Normal linear model",
                "Deming regression",
                "Predicted peak A.FB (lm)",
                "Predicted peak A.FB (deming)"),
       col=c("red", "blue", "blue", "green"),
       lty=c(1, 1, 0, 0),
       pch=c(-1, -1, 1, 1)
)
